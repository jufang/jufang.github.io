<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深复制和浅复制]]></title>
    <url>%2F2017%2F11%2F29%2FdeepCopyAndShallowCopy%2F</url>
    <content type="text"><![CDATA[对于字符串类型，浅复制是对值的复制，对于对象来说，浅复制是对对象地址的复制，并没 有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。深复制实现代码如下：可以从两个方法进行解决。 赋值1.值类型赋值不会改变原对象，对象类型的赋值会改变原对象 1234var a = &#123;c:2&#125;;var b = a ;b.c=1console.log(a) // &#123;c:1&#125; 改变了原对象 浅拷贝先上代码，dst[prop] = src[prop] ,不管值类型和对象类型进行赋值，如果是值类型不会出现问题，引用类型数据会改变原对象 123456789101112131415161718var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(o) &#123; var res = &#123;&#125;; for (var i in o) &#123; if (o.hasOwnProperty(i)) &#123; res[i] = o[i]; &#125; &#125; return res;&#125;shallowObj.a = 2shallowObj.arr.push(4) console.dir(obj) // &#123;a:1,arr:[2,3,4]&#125;console.dir(shallowObj) // &#123;a:2,arr:[2,3,4]&#125; JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址导致:123shallowObj.arr.push(4) 时，shallowObj.arr[2]=4, obj.arr[2] =4 深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。 通过递归解析解决12345678910111213141516171819202122232425262728var clone= function(origin,target)&#123; target = target || &#123;&#125;; for(var i in origin)&#123; if(origin.hasOwnProperty(i))&#123; //复杂数据类型 if(typeof origin[i]===&apos;object&apos;)&#123; if(origin[i].constructor === Array)&#123; target[i] = [] &#125;else&#123; target[i] = &#123;&#125; &#125; arguments.callee(origin[i],target[i]) &#125;else&#123; target[i] = origin[i] &#125; &#125; &#125; return target&#125;//测试var obj = &#123; a:1, arr: [1,2] &#125;;var result = clone(obj,&#123;b:2&#125;);result[&apos;arr&apos;].push(4)console.log(obj) //原对象不变 &#123; a:1, arr: [1,2] &#125;console.log(result) // &#123; a:1, b:2 arr: [1,2,4] &#125; 通过JSON解析解决1var result = JSON.parse(JSON.stringify(origin))]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[microEvent.js 微事件]]></title>
    <url>%2F2017%2F04%2F13%2FmicroEvent%2F</url>
    <content type="text"><![CDATA[npm 安装1npm i microevent-github --save 浏览器1&lt;script src=&quot;microevent.js&quot;&gt;&lt;/script&gt; node1var MicroEvent = require(&apos;./microevent.js&apos;) 使用12345678910111213141516171819202122//定义一个ticker函数，每秒触发‘tick’事件var Ticker = function()&#123; var self = this; setInterval(function()&#123; self.trigger(&apos;tick&apos;, new Date()); &#125;, 1000);&#125;;//将MicroEvent上的三个事件赋值给Ticker对象，这样对象就可以调用bind,unbind,和trigger方法了MicroEvent.mixin(Ticker);//创建一个实例var ticker = new Ticker();//绑定tick事件，触发ticker.bind(&apos;tick&apos;, function(date) &#123; console.log(&apos;notified date&apos;, date);&#125;);输出；notified date Tue, 22 Mar 2011 14:43:41 GMTnotified date Tue, 22 Mar 2011 14:43:42 GMT... 源码123456789101112131415161718192021222324252627282930313233343536var MicroEvent = function()&#123;&#125;;MicroEvent.prototype = &#123; bind : function(event, fct)&#123; this._events = this._events || &#123;&#125;; this._events[event] = this._events[event] || []; this._events[event].push(fct); &#125;, unbind : function(event, fct)&#123; this._events = this._events || &#123;&#125;; if( event in this._events === false ) return; this._events[event].splice(this._events[event].indexOf(fct), 1); &#125;, trigger : function(event /* , args... */)&#123; this._events = this._events || &#123;&#125;; if( event in this._events === false ) return; for(var i = 0; i &lt; this._events[event].length; i++)&#123; this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1)); &#125; &#125;&#125;;MicroEvent.mixin = function(destObject)&#123; var props = [&apos;bind&apos;, &apos;unbind&apos;, &apos;trigger&apos;]; for(var i = 0; i &lt; props.length; i ++)&#123; if( typeof destObject === &apos;function&apos; )&#123; destObject.prototype[props[i]] = MicroEvent.prototype[props[i]]; &#125;else&#123; destObject[props[i]] = MicroEvent.prototype[props[i]]; &#125; &#125;&#125;// 全局调用函数MicroEventif( typeof module !== &quot;undefined&quot; &amp;&amp; (&apos;exports&apos; in module))&#123; module.exports = MicroEvent;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个简单的模块加载]]></title>
    <url>%2F2017%2F03%2F15%2FsimpleAmdLoader%2F</url>
    <content type="text"><![CDATA[模块定义123function define(name,dependencies,factory)&#123; ...&#125; 模块使用,传一个对应模块名称，然后返回此模块的回调函数use(name) 模块加载可以加载那些必须的，剩下的在需要的时候去加载require([mod1…modn],callback) 实现一个简单模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function()&#123; var moduleMap=&#123;&#125;,fileMap=&#123;&#125; var thin=&#123; //定义模块 name不能重复,返回一个模块的存储结构 define:function(name,dependencies,factory)&#123; if(!moduleMap[name])&#123; var module=&#123; name:name, dependencies:dependencies, factory:factory &#125; moduleMap[name]=module &#125; return moduleMap[name] &#125;, use:function(name)&#123; var module = moduleMap[name]; if(!module.entity)&#123; var args=[]; for(var i=0;i&lt;module.dependencies.length;i++)&#123; if (moduleMap[module.dependencies[i]].entity) &#123; args.push(moduleMap[module.dependencies[i]].entity); &#125;else&#123; args.push(this.use(module.dependencies[i])) &#125; &#125; module.entity=module.factory.apply(null,args) &#125; return module.entity &#125;, //检查所有的fileArr路径是否加载完成,加载完成就执行回调 //http://coolshell.cn/articles/9749.html#jtss-tsina require:function(fileArr,callback)&#123; for(var i=0;i&lt;fileArr.length;i++)&#123; var path=fileArr[i]; //用来标示是否加载完 if(!fileMap[path])&#123; var head=document.getElementsByTagName(&apos;head&apos;)[0] var script=document.createElement(&apos;script&apos;); script.type=&quot;text/javascript&quot; script.src=path+&apos;.js&apos; script.onload=function()&#123; fileMap[path]=true; head.removeChild(script); checkAllFiles() &#125; head.appendChild(script) &#125; &#125; function checkAllFiles()&#123; var allLoaded=true; for(var i=0;i&lt;fileArr.length;i++)&#123; if(!fileMap[fileArr[i]])&#123; allLoaded=false; break; &#125; &#125; if(allLoaded)&#123; callback() &#125; &#125; &#125; &#125; //只定义一个全局作用域，其他函数由其管理 window.thin=thin;&#125;)() 测试文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253thin.define(&apos;constant.PI&apos;,[],function()&#123; return 3.1415926;&#125;)thin.define(&apos;shape.Circle&apos;,[&quot;constant.PI&quot;],function(pi)&#123; var Circle=function(r)&#123; this.r=r &#125; Circle.prototype=&#123; area:function()&#123; return pi * this.r *this.r &#125; &#125; return Circle&#125;)thin.define(&apos;shape.Rectangle&apos;,[],function()&#123; var Rectangle=function(l,w)&#123; this.l=l; this.w=w; &#125; Rectangle.prototype=&#123; area:function()&#123; return this.l * this.w &#125; &#125; return Rectangle&#125;)thin.define(&apos;shapeType&apos;,[&quot;shape.Circle&quot;,&quot;shape.Rectangle&quot;],function(Circle,Rectangle)&#123; return &#123; CIRCLE:Circle, RECTANGLE:Rectangle &#125;&#125;)thin.define(&apos;ShapeFactory&apos;,[&apos;shapeType&apos;],function(ShapeTypes)&#123; return &#123; getShape:function(type)&#123; var shape; switch (type)&#123; case &quot;CIRCLE&quot;: shape=new ShapeTypes[type]( arguments[1]) break; case &quot;RECTANGLE&quot;: shape=new ShapeTypes[type](arguments[1],arguments[2]) break &#125; return shape &#125; &#125;&#125;)var shapeFactory= thin.use (&quot;ShapeFactory&quot;);alert( shapeFactory.getShape (&quot;CIRCLE&quot;,5).area())alert(shapeFactory.getShape(&quot;RECTANGLE&quot;,3,5).area())]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Amd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 对象继承]]></title>
    <url>%2F2017%2F03%2F14%2FobjectInheritance%2F</url>
    <content type="text"><![CDATA[构造函数1234567891011121314151617var Book=function(id,name,price)&#123; var a=1; this.id=id; this.name=name; this.price=price; this.getPirce=function()&#123; return this.price &#125;&#125;Book.prototype.display=function()&#123;//展示这本书&#125;var book1 = new Book(1,&quot;js设计&quot;,100);var book2 = new Book(2,&quot;nodejs指南&quot;,50);Book.isChinese=true //类静态公有属性（实例化对象不能访问） 打印book1123456789//Book getPirce:function() id:1 name:&quot;js设计&quot; price:100 __proto__:Object constructor:function(id,name,price) display:function() __proto__:Object 子类的原型对象-类式继承缺点，如果父类公有属性是引用类型如数组，就会被所有子类的实例公有，其中一个实例更改公有数据会直接影响到其他子类1234567891011121314function Father()&#123; this.fVal=true;&#125;Father.prototype.getFatherVal=function()&#123; return this.fVal&#125;function Children()&#123; this.cVal=false;&#125;Children.prototype=new Father();Children.prototype.getChildVal=function()&#123; return this.cVal&#125;var instance=new Children(); 打印instance:12345678cVal:false__proto__:Father fVal:true getChildVal:function() __proto__:Object constructor:function Father() getFatherVal:function() __proto__:Object 创建即继承-构造函数继承缺点：父类的原型方法不会被子类继承1234567891011121314151617181920//申明父类function Father(id)&#123; //值类型共有属性 this.id=id //引用类型共用属性 this.books=[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;]&#125;Father.prototype.showBooks=function()&#123; return this.books&#125;//申明子类function Children(id)&#123; Father.call(this,id) //call改变函数的作用环境，子类继承父类的共有属性和方法。&#125;var instance1=new Children(10);var instance2=new Children(12);instance1.books.push(&apos;设计模式&apos;)console.log(instance1.id,instance1.books) //10,[&quot;Javascript&quot;, &quot;nodejs&quot;, &quot;css&quot;, &quot;设计模式&quot;]console.log(instance1.id,instance2.books) //12,[&quot;Javascript&quot;, &quot;nodejs&quot;, &quot;css&quot;]instance1.showBooks() //TypeError 组合继承缺点:构造函数式继承执行一遍父类的构造函数，子类原型的类方式继承又调用一次父类的构造函数123456789101112131415161718192021222324252627//申明父类的构造函数function Father(id)&#123; //值类型共有属性 this.id=id //引用类型共用属性 this.books=[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;]&#125;//父类申明原型方法Father.prototype.getId=function()&#123; console.log(this.id)&#125;//申明子类function Children(id,price)&#123; //构造函数式继承父类id属性和books Father.call(this,id); //子类新增共用属性 this.price=price&#125;Children.prototype=new Father();Children.prototype.getPrice=function()&#123; console.log(this.price)&#125;var instance1=new Children(10,50.00)instance1.books.push(&apos;设计模式&apos;);var instance2=new Children(12,65.00); 打印instance11234567891011id:10books:[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;,&apos;设计模式&apos;]price:50,__proto__:Father id:undefind books:[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;] getPrice:function() __proto__:Object constructor:function Father(id) getId:function() __proto__:Object 洁净的继承者-原型式继承缺点：同类式继承12345678910111213141516171819function inhertObject(o)&#123; //过渡函数对象 function F()&#123;&#125; //过渡对象原型继承父对象 F.prototype=o //返回过渡对象的一个实例，该实例原型继承父对象 return new F()&#125;var books=&#123; name:&apos;js book&apos;, alikebook:[&apos;css&apos;,&apos;html&apos;]&#125;var book1=inhertObject(books);book1.name=&apos;ajax book&apos;book1.alikebook.push(&apos;xml&apos;)var book2=inhertObject(books);book2.name=&apos;flash book&apos;book2.alikebook.push(&apos;actionscript&apos;) 终极组合继承1234567891011121314151617181920212223242526272829303132333435363738394041424344function inhertObject(o)&#123; //过渡函数对象 function F()&#123;&#125; //过渡对象原型继承父对象 F.prototype=o //返回过渡对象的一个实例，该实例原型继承父对象 return new F() &#125; function inhertProto(children,father)&#123; //复制一份父类的原型副本保存在变量中 var p=inhertObject(father.prototype) //修正因为改写子类导致子类的constructor熟悉被修改 p.constructor=children; //修改子类的原型 children.prototype=p; &#125; //申明父类的构造函数 function Father(id)&#123; //值类型共有属性 this.id=id //引用类型共用属性 this.books=[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;] &#125; //父类申明原型方法 Father.prototype.getId=function()&#123; console.log(this.id) &#125; //申明子类 function Children(id,price)&#123; //构造函数式继承父类id属性和books Father.call(this,id); //子类新增共用属性 this.price=price &#125; //Children.prototype=new Father(); inhertProto(Children,Father); Children.prototype.getPrice=function()&#123; console.log(this.price) &#125; var instance1=new Children(10,50.00) instance1.books.push(&apos;设计模式&apos;); var instance2=new Children(12,65.00); 打印instance112345678910id:10books:[&apos;Javascript&apos;,&apos;nodejs&apos;,&apos;css&apos;,&apos;设计模式&apos;]price:50,__proto__:Father constructor:function Children(id,price) getPrice:function() __proto__:Object constructor:function Father(id) getId:function() __proto__:Object]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node代理与缓存]]></title>
    <url>%2F2017%2F03%2F03%2FproxyAndCache%2F</url>
    <content type="text"><![CDATA[正向代理正向代理的过程，它隐藏真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务器都被代理服务代替请求，比如浏览器访问google.com，被拦截，于是你在国外搭建一台代理服务器，让代理服务器请求google.com 代理把请求结果返回给我反向代理隐藏真实的服务端 反向代理 当我们请求www.baidu.com时候，背后有很多服务器为我们服务,www.baidu.com就是我们的反向代理服务器，反向代理服务器会将请求转发到真实的服务器中两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端 node-http-proxy一个支持反向代理和负载均衡的npm包 12345678910111213//以前你访问资源是从http://localhost:9000取得，现在通过反向代理服务器http://localhost:8000,他去请求9000端口的内容var http = require(&apos;http&apos;), httpProxy = require(&apos;http-proxy&apos;);// 创建代理服务器httpProxy.createProxyServer(&#123;target:&apos;http://localhost:9000&apos;&#125;).listen(8000);// 创建目标服务器（http://localhost:9000）http.createServer(function (req, res) &#123; res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); res.write(&apos;request successfully proxied!&apos; + &apos;\n&apos; + JSON.stringify(req.headers, true, 2)); res.end();&#125;).listen(9000); 配置gzip压缩 开启网站的 gzip 压缩功能，通常可以高达70%，也就是说，如果你的网页有30K，压缩之后就变成9K， 对于大部分网站，显然可以明显提高浏览速度（注：需要浏览器支持）。 12var compression = require(&apos;compression&apos;);app.use(compression()); 配置http缓存：maxAge、etag、lastModified等 1234567app.use(express.static(path.join(__dirname, &apos;public&apos;), &#123; maxAge:100, etag:true, lastModified:true &#125;)); 配置combo 12345678app.get(&apos;/javascripts&apos;, combo.combine(&#123;rootPath: path.join(__dirname, &apos;public&apos;)+&apos;/javascripts&apos;&#125;), combo.respond);app.get(&apos;/stylesheets&apos;, combo.combine(&#123;rootPath: path.join(__dirname, &apos;public&apos;)+&apos;/stylesheets&apos;&#125;), combo.respond); 配置ssi SSI是服务器端嵌入指令,在内容发送到浏览器之前，解析指令标签将其内容包含到网页中 1expressSSI.init(express,&apos;http://gome.com.cn&apos;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容各版本的闭包函数]]></title>
    <url>%2F2017%2F03%2F03%2FCompatibleClosure%2F</url>
    <content type="text"><![CDATA[通常一个自执行的闭包函数是这样的123(function(this,$)&#123;...&#125;(window,jQuery)) 等同于下面写法123!function(this,$)&#123;...&#125;(window,jQuery) 兼容node环境 或者amd写法 和window写法举一个小李子：先定义一个circle.js，暴露两个公共函数给外部调用1234567891011121314151617181920212223242526!function(root,fn)&#123; if (typeof exports === &apos;object&apos;) &#123; // Node. module.exports = fn.call(root); &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // 定义一个匿名模块 define(function()&#123; return fn.call(root) &#125;); &#125; else &#123; // Browser globals (root is window) root.circle = fn.call(root); &#125;&#125;(this,function()&#123; var PI=Math.PI; //面积计算方法 var area=function(r)&#123; return PI * r * r; &#125; //周长计算方法 var circumference = function (r) &#123; return 2 * PI * r; &#125;; return &#123; area:area, circumference:circumference &#125;&#125;) app.js 调用circle中的方法123456789101112!function(root,fn)&#123; if (typeof exports === &apos;object&apos;) &#123; module.exports = fn.call(root,require(&quot;./circle.js&quot;)); &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; //定义一个circle模块加异步下载circle.js 加载完成执行回调 define([&quot;circle&quot;],function(c)&#123; return fn.call(root,c) &#125;); &#125; else &#123; root.circle = fn.call(root,circle); &#125;&#125;(this,function(c)&#123; console.log(c.area(4))&#125;) 写一个index.html 跑一下这是node环境和window环境引用两个文件12&lt;script src=&quot;circle.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; 如果需要用require异步加载文件，只需要引入一个require.js源文件就可以12&lt;script data-main=&quot;app.js&quot; src=&quot;require.js&quot;&gt;&lt;/script&gt;然后我们在控制台就看到打印的结果了50.26548245743669]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2017%2F03%2F02%2FArrayGeneralFun%2F</url>
    <content type="text"><![CDATA[自定义数组range1234567891011Array.apply(null,&#123;length:3&#125;) //[undefined, undefined, undefined]Array.call(null,&#123;length:3&#125;) //[&#123;length:3&#125;]var a=[]Array.prototype.range=function(start,end)&#123; var length=end-start; var step = start - 1; return Array.apply(null,&#123;length:length&#125;).map(function(v,i)&#123;step++;return step&#125;) &#125;a.range(0,100) //显示0到99的数组 或者R.range(0,100) arrayObj.toString()作用：将数组转化成字符串，与不穿参调用join方法相似12[1, 2, 3].toString(); //输出 &apos;1, 2, 3&apos;[1, 2, [3, 4]].toString(); //输出 &apos;1, 2, 3, 4&apos; 字符转数组12var a=&quot;a|bbb,3214 ccc&quot;a.match(/[^,| ]+/g) // [&quot;a&quot;, &quot;bbb&quot;, &quot;3214&quot;, &quot;ccc&quot;] arrayObj.join([seperator])作用：将数组的各个元素转成字符串，再以seperator为分隔符，将数组连接成一个字符串后注意：seperator可选，如没有指定seperator，默认用“，”来连接字符串 arrayObj.concat(element1, element2, …, elementX)作用：连接两个或多个数组，返回连接后的数组；注意：不修改原数组；如果不传任何参数，则返回原数组的一份拷贝；如果参数不是数组，则将参数添加到连接的数组后面；如果传入的参数是数组，则将参数数组的每个元素添加到连接的数组后面；1234var arr1=[1,3,4];var arr2=[3,4,5];arr1.concat(arr2) //返回[1, 3, 4, 3, 4, 5] 不改变arr1的值Array.prototype.push.apply(arr1,arr2) //6返回长度，arr1值为[1, 3, 4, 3, 4, 5] arrayObj.slice(start, end) //切片函数，不改变原数组作用：从已有的数组中返回指定元素组成的新数组，包括start指定位置的元素，但不包含end处包含的元素；注意：start必选，end可选；当start或end为负值时，表示从数组最后一个元素开始，倒数第n个元素，比如数 组最后一个元素为倒数第一个；当没有指定end时，则截取从start开始，一直到最后一个元素；arguments参数是个伪数组，通过 Array.prototype.slice.call(arguments) 转化为标准数组1234var arr = [1, 2, 3];arr.slice(0 ,2); //输出 [1, 2]，此时arr=&gt;[1, 2, 3]arr.slice(-2, -1); //输出 [2]arr.slice(1); //输出 [2, 3] arrayObj.splice(index, howmany, element1, element2…, elementX) //返回被删除数组，会改变原数组作用：从index处开始，从数组里删除howmany个元素后，将element1~elementX插入到数组中，插入开始的位置为index；返回值为删除的元素组成的数组；注意：会修改原数组；howmany可选，如只传入index，则删除从index开始的所有元素；如howmany为0，则删除0个元素；如果传入的element为数组，不会像slice方法那样插入单个元素，而是将数组作为整个元素插入；123456789101112var arr = [1, 2, 3];arr.splice(0, 1); //输出 [1]，此时arr=&gt;[2, 3]arr = [1, 2, 3];arr.splice(1, 0, &apos;hello&apos;); //输出 []，此时 arr=&gt;[1, &apos;hello&apos;, 2, 3]arr = [1, 2, 3];arr.splice(1); //输出 [2, 3]，此时arr=&gt;[1]arr = [1, 2, 3];arr.splice(1, 0, [&apos;hello&apos;, &apos;world&apos;]); //输出 []//此时arr=&gt; [1, [&apos;hello&apos;, &apos;world&apos;], 2, 3] arrayObj.push(newElement1, newElement2, … newElementX)作用：向数组末尾添加一个或多个元素，并返回修改后的数组长度注意：会修改原数组；返回修改后的数组长度12var arr = [1, 2, 3];arr.push(4, 5); //输出 5，此时arr=&gt;[1,2,3,4,5] arrayObj.pop()作用：删除并返回数组最后一个元素 arrayObj.shift()作用：删除并返回数组第一个元素 arrayObj.unshift()作用：向数组开头添加一个或多个元素，返回修改后的数组长度注意：会修改原数组；返回的是修改后的数组长度；在IE6里，返回的是undefined arrayObj.reverse()作用：将数组元素的排序全部颠倒过来注意：会修改原有数组12var arr = [1, 2, 3];arr.reverse(); //输出 [3, 2, 1]，此时arr=&gt;[3, 2 1] arrayObj.sort([sortFunc])作用：对数组元素进行排序；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git写文章的几条命令]]></title>
    <url>%2F2017%2F03%2F01%2Fhowhexo%2F</url>
    <content type="text"><![CDATA[到blog所在的代码目录启动命令行 新建文章hexo new howhexo12D:\GOMEWORK\blog&gt; hexo new howhexoINFO Created: D:\GOMEWORK\blog\source\_posts\howhexo.md 启动本地serverhexo server 或者hexo s123D:\GOMEWORK\blog&gt; hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此时你输入http://localhost:4000/就可以看到你blog的文章了然后你就使用markdown 在source/_posts/howhexo.md 去写文章 再发布之前需要生成一下hexo generate 或 hexo g]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2F2017%2F03%2F01%2FMarkDownUse%2F</url>
    <content type="text"><![CDATA[标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 粗体与斜体两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 **这里是粗体***这里是斜体* 列表#### 无序列表* 1* 2* 3 #### 有序列表1. a2. b3. c 引用&gt; 这里是引用，注意&gt;之间的空格 图片与链接图片为：![](){ImgCap}{/ImgCap}链接为：[]() 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 代码用3 包裹代码块 行内锚点[行内标题](#行内标题) 文章目录 下载 使用 示例项目 Action 变更应用状态 异步过程 组件的connect mapstates mapActions]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
